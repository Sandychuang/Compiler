identifier :Functor
identifier :Monad
identifier :functor1
oprator :)
reserved :return
int_number :1
oprator :;
reserved :else
reserved :return
identifier :a
oprator :*
identifier :fact
oprator :(
identifier :a
oprator :-
int_number :1
oprator :)
oprator :;
oprator :}
reserved :int
identifier :fib
oprator :(
reserved :int
identifier :a
oprator :)
oprator :{
reserved :if
oprator :(
identifier :a
oprator :<
int_number :3
oprator :)
reserved :return
int_number :1
oprator :;
reserved :else
reserved :return
identifier :fib
oprator :(
identifier :a
oprator :-
int_number :1
oprator :)
oprator :+
identifier :fib
oprator :(
identifier :a
oprator :-
int_number :2
oprator :)
oprator :;
oprator :}
reserved :int
identifier :a
oprator :=
int_number :1
oprator :;
reserved :int
identifier :b
oprator :=
identifier :fib
oprator :(
identifier :a
oprator :)
oprator :;
reserved :int
oprator :[
oprator :]
oprator :[
oprator :]
identifier :as
oprator :=
reserved :new
reserved :int
oprator :[
int_number :10
oprator :]
oprator :[
int_number :10
oprator :]
oprator :;
identifier :as
oprator :[
int_number :0
oprator :]
oprator :[
int_number :0
oprator :]
oprator :=
int_number :6
oprator :;
reserved :int
identifier :b
oprator :=
identifier :as
oprator :[
int_number :1
oprator :]
oprator :[
int_number :1
oprator :]
oprator :;
reserved :class
identifier :A
oprator :<
identifier :T1
oprator :>
oprator :{
identifier :T1
identifier :a
oprator :;
oprator :<
identifier :T2
oprator :,
identifier :T3
oprator :>
identifier :T1
identifier :f
oprator :(
identifier :T2
identifier :b
oprator :,
identifier :T3
identifier :c
oprator :)
oprator :{
reserved :return
reserved :this
oprator :.
identifier :a
oprator :;
oprator :}
oprator :}
reserved :class
identifier :B
oprator :<
identifier :T1
oprator :>
reserved :extends
identifier :A
oprator :{
identifier :T1
identifier :b
oprator :;
oprator :<
identifier :T2
oprator :,
identifier :T3
oprator :>
identifier :T1
identifier :f
oprator :(
identifier :T2
identifier :b
oprator :,
identifier :T3
identifier :c
oprator :)
oprator :{
reserved :return
reserved :this
oprator :.
identifier :b
oprator :;
oprator :}
oprator :}
identifier :A
oprator :<
reserved :bool
oprator :>
identifier :ga
oprator :=
reserved :new
identifier :B
oprator :<
reserved :bool
oprator :>
oprator :(
oprator :)
oprator :;
reserved :bool
identifier :t
oprator :=
identifier :ga
oprator :.
oprator :<
reserved :int
oprator :,
reserved :int
oprator :>
identifier :f
oprator :(
int_number :1
oprator :,
int_number :2
oprator :)
oprator :;
reserved :function
identifier :f
oprator :=
oprator :(
reserved :int
identifier :a
oprator :)
oprator :->
oprator :{
reserved :return
oprator :(
oprator :)
oprator :->
oprator :{
reserved :return
int_number :1
oprator :;
oprator :}
oprator :;
oprator :}
oprator :;
identifier :f
oprator :(
int_number :1
oprator :)
oprator :;
oprator :*
oprator :/
reserved :class
identifier :Functor
oprator :<
identifier :T1
oprator :>
oprator :{
identifier :T1
identifier :t
oprator :;
oprator :<
identifier :T2
oprator :>
identifier :Functor
oprator :<
identifier :T2
oprator :>
identifier :fmap
oprator :(
reserved :function
identifier :f
oprator :,
identifier :Functor
oprator :<
identifier :T1
oprator :>
identifier :wa
oprator :)
oprator :{
identifier :T2
identifier :b
oprator :=
identifier :f
oprator :(
identifier :wa
oprator :.
identifier :t
oprator :)
oprator :;
identifier :Functor
oprator :<
identifier :T2
oprator :>
identifier :fb
oprator :=
reserved :new
identifier :Functor
oprator :<
identifier :T2
oprator :>
oprator :(
oprator :)
oprator :;
identifier :fb
oprator :.
identifier :t
oprator :=
identifier :b
oprator :;
reserved :return
identifier :fb
oprator :;
oprator :}
oprator :}
identifier :Functor
oprator :<
reserved :int
oprator :>
identifier :a
oprator :=
reserved :new
identifier :Functor
oprator :<
reserved :int
oprator :>
oprator :(
oprator :)
oprator :;
identifier :a
oprator :.
identifier :t
oprator :=
int_number :1
oprator :;
identifier :Functor
oprator :<
reserved :bool
oprator :>
identifier :b
oprator :=
reserved :new
identifier :Functor
oprator :<
reserved :bool
oprator :>
oprator :(
oprator :)
oprator :;
reserved :function
identifier :f
oprator :=
oprator :(
reserved :int
identifier :i
oprator :)
oprator :->
oprator :{
reserved :if
oprator :(
identifier :i
oprator :>
int_number :0
oprator :)
reserved :return
reserved :true
oprator :;
reserved :else
reserved :return
reserved :false
oprator :;
oprator :}
oprator :;
identifier :b
oprator :=
identifier :a
oprator :.
oprator :<
reserved :bool
oprator :>
identifier :fmap
oprator :(
identifier :f
oprator :,
identifier :a
oprator :)
oprator :;
reserved :class
identifier :Monad
oprator :<
identifier :T1
oprator :>
reserved :extends
identifier :Functor
oprator :{
identifier :Monad
oprator :<
identifier :T1
oprator :>
identifier :rt
oprator :(
identifier :T1
identifier :t
oprator :)
oprator :{
identifier :Monad
oprator :<
identifier :T1
oprator :>
identifier :ma
oprator :=
reserved :new
identifier :Monad
oprator :<
identifier :T1
oprator :>
oprator :(
oprator :)
oprator :;
identifier :ma
oprator :.
identifier :t
oprator :=
identifier :t
oprator :;
reserved :return
identifier :ma
oprator :;
oprator :}
oprator :<
identifier :T2
oprator :>
identifier :Monad
oprator :<
identifier :T2
oprator :>
identifier :lk
oprator :(
identifier :Monad
oprator :<
identifier :T1
oprator :>
identifier :ma
oprator :,
reserved :function
identifier :f
oprator :)
oprator :{
identifier :Monad
oprator :<
identifier :T2
oprator :>
identifier :mb
oprator :=
identifier :f
oprator :(
identifier :ma
oprator :.
identifier :t
oprator :)
oprator :;
reserved :return
identifier :mb
oprator :;
oprator :}
oprator :}
eof: end of file!
